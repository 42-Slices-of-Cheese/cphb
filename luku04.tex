\chapter{Data structures}

\index{data structure}

A \key{data structure} is a way to store
data in the memory of the computer.
It is important to choose a suitable
data structure for a problem,
because each data structure has its own
advantages and disadvantages.
The crucial question is: which operations
are efficient in the chosen data structure?

This chapter introduces the most important
data structures in the C++ standard library.
It is a good idea to use the standard library
whenever possible,
because it will save a lot of time.
Later in the book we will learn more sophisticated
data structures that are not available
in the standard library.

\section{Dynamic array}

\index{dynamic array}
\index{vector}
\index{vector@\texttt{vector}}

A \key{dynamic array} is an array whose
size can be changed during the execution
of the code.
The most popular dynamic array in C++ is
the \key{vector} structure (\texttt{vector}),
that can be used almost like a regular array.

The following code creates an empty vector and
adds three elements to it:

\begin{lstlisting}
vector<int> v;
v.push_back(3); // [3]
v.push_back(2); // [3,2]
v.push_back(5); // [3,2,5]
\end{lstlisting}

After this, the elements can be accessed like in a regular array:

\begin{lstlisting}
cout << v[0] << "\n"; // 3
cout << v[1] << "\n"; // 2
cout << v[2] << "\n"; // 5
\end{lstlisting}

The function \texttt{size} returns the number of elements in the vector.
The following code iterates through
the vector and prints all elements in it:

\begin{lstlisting}
for (int i = 0; i < v.size(); i++) {
    cout << v[i] << "\n";
}
\end{lstlisting}

\begin{samepage}
A shorter way to iterate trough a vector is as follows:

\begin{lstlisting}
for (auto x : v) {
    cout << x << "\n";
}
\end{lstlisting}
\end{samepage}

The function \texttt{back} returns the last element
in the vector, and
the function \texttt{pop\_back} removes the last element:

\begin{lstlisting}
vector<int> v;
v.push_back(5);
v.push_back(2);
cout << v.back() << "\n"; // 2
v.pop_back();
cout << v.back() << "\n"; // 5
\end{lstlisting}

The following code creates a vector with five elements:

\begin{lstlisting}
vector<int> v = {2,4,2,5,1};
\end{lstlisting}

Another way to create a vector is to give the number
of elements and the initial value for each element:

\begin{lstlisting}
// size 10, initial value 0
vector<int> v(10);
\end{lstlisting}
\begin{lstlisting}
// size 10, initial value 5
vector<int> v(10, 5);
\end{lstlisting}

The internal implementation of the vector
uses a regular array.
If the size of the vector increases and
the array becomes too small,
a new array is allocated and all the
elements are copied to the new array.
However, this doesn't happen often and the
time complexity of
\texttt{push\_back} is $O(1)$ on average.

\index{string}
\index{string@\texttt{string}}

Also the \key{string} structure (\texttt{string})
is a dynamic array that can be used almost like a vector.
In addition, there is special syntax for strings
that is not available in other data structures.
Strings can be combined using the \texttt{+} symbol.
The function $\texttt{substr}(k,x)$ returns the substring
that begins at index $k$ and has length $x$.
The function $\texttt{find}(\texttt{t})$ finds the position
where a substring \texttt{t} appears in the string.

The following code presents some string operations:

\begin{lstlisting}
string a = "hatti";
string b = a+a;
cout << b << "\n"; // hattihatti
b[5] = 'v';
cout << b << "\n"; // hattivatti
string c = b.substr(3,4);
cout << c << "\n"; // tiva
\end{lstlisting}

\section{Set structure}

\index{set}
\index{set@\texttt{set}}
\index{unordered\_set@\texttt{unordered\_set}}

A \key{set} is a data structure that
contains a collection of elements.
The basic operations in a set are element
insertion, search and removal.

C++ contains two set implementations:
\texttt{set} and \texttt{unordered\_set}.
The structure \texttt{set} is based on a balanced
binary tree and the time complexity of its
operations is $O(\log n)$.
The structure \texttt{unordered\_set} uses a hash table,
and the time complexity of its operations is $O(1)$ on average.

The choice which set implementation to use
is often a matter of taste.
The benefit in the \texttt{set} structure
is that it maintains the order of the elements
and provides functions that are not available
in \texttt{unordered\_set}.
On the other hand, \texttt{unordered\_set} is
often more efficient.

The following code creates a set
that consists of integers,
and shows how to use it.
The function \texttt{insert} adds an element to the set,
the function \texttt{count} returns how many times an
element appears in the set,
and the function \texttt{erase} removes an element from the set.

\begin{lstlisting}
set<int> s;
s.insert(3);
s.insert(2);
s.insert(5);
cout << s.count(3) << "\n"; // 1
cout << s.count(4) << "\n"; // 0
s.erase(3);
s.insert(4);
cout << s.count(3) << "\n"; // 0
cout << s.count(4) << "\n"; // 1
\end{lstlisting}

A set can be used mostly like a vector,
but it is not possible to access
the elements using the \texttt{[]} notation.
The following code creates a set,
prints the number of elements in it, and then
iterates through all the elements:
\begin{lstlisting}
set<int> s = {2,5,6,8};
cout << s.size() << "\n"; // 4
for (auto x : s) {
    cout << x << "\n";
}
\end{lstlisting}

An important property of a set is
that all the elements are distinct.
Thus, the function \texttt{count} always returns
either 0 (the element is not in the set)
or 1 (the element is in the set),
and the function \texttt{insert} never adds
an element to the set if it is
already in the set.
The following code illustrates this:

\begin{lstlisting}
set<int> s;
s.insert(5);
s.insert(5);
s.insert(5);
cout << s.count(5) << "\n"; // 1
\end{lstlisting}

\index{multiset@\texttt{multiset}}
\index{unordered\_multiset@\texttt{unordered\_multiset}}

C++ also contains the structures
\texttt{multiset} and \texttt{unordered\_multiset}
that work otherwise like \texttt{set}
and \texttt{unordered\_set}
but they can contain multiple copies of an element.
For example, in the following code all copies
of the number 5 are added to the set:

\begin{lstlisting}
multiset<int> s;
s.insert(5);
s.insert(5);
s.insert(5);
cout << s.count(5) << "\n"; // 3
\end{lstlisting}
The function \texttt{erase} removes
all instances of an element
from a \texttt{multiset}:
\begin{lstlisting}
s.erase(5);
cout << s.count(5) << "\n"; // 0
\end{lstlisting}
Often, only one instance should be removed,
which can be done as follows:
\begin{lstlisting}
s.erase(s.find(5));
cout << s.count(5) << "\n"; // 2
\end{lstlisting}

\section{Map structure}

\index{hakemisto@hakemisto}
\index{map@\texttt{map}}
\index{unordered\_map@\texttt{unordered\_map}}

\key{Hakemisto} on taulukon yleistys,
joka sisältää kokoelman avain-arvo-pareja.
Siinä missä taulukon avaimet ovat aina peräkkäiset
kokonaisluvut $0,1,\ldots,n-1$,
missä $n$ on taulukon koko,
hakemiston avaimet voivat
olla mitä tahansa tyyppiä
eikä niiden tarvitse olla peräkkäin.

C++ sisältää kaksi toteutusta hakemistolle
samaan tapaan kuin joukolle.
Rakenne
\texttt{map} perustuu
tasapainoiseen binääripuuhun ja sen
alkioiden käsittely vie aikaa $O(\log n)$,
kun taas rakenne
\texttt{unordered\_map} perustuu
hajautustauluun ja sen alkioiden
käsittely vie keskimäärin aikaa $O(1)$.

Seuraava koodi toteuttaa hakemiston,
jossa avaimet ovat merkkijonoja ja
arvot ovat kokonaislukuja:

\begin{lstlisting}
map<string,int> m;
m["apina"] = 4;
m["banaani"] = 3;
m["cembalo"] = 9;
cout << m["banaani"] << "\n"; // 3
\end{lstlisting}

Jos hakemistosta hakee avainta,
jota ei ole siinä,
avain lisätään hakemistoon
automaattisesti oletusarvolla.
Esimerkiksi seuraavassa koodissa
hakemistoon ilmestyy avain ''aybabtu'',
jonka arvona on 0:

\begin{lstlisting}
map<string,int> m;
cout << m["aybabtu"] << "\n"; // 0
\end{lstlisting}
Funktiolla \texttt{count} voi
tutkia, esiintyykö avain hakemistossa:
\begin{lstlisting}
if (m.count("aybabtu")) {
    cout << "avain on hakemistossa";
}
\end{lstlisting}
Seuraava koodi listaa hakemiston
kaikki avaimet ja arvot:
\begin{lstlisting}
for (auto x : m) {
    cout << x.first << " " << x.second << "\n";
}
\end{lstlisting}

\section{Iteraattorit ja välit}

\index{iteraattori@iteraattori}

Monet C++:n standardikirjaston funktiot
käsittelevät tietorakenteiden iteraattoreita
ja niiden määrittelemiä välejä.
\key{Iteraattori} on muuttuja,
joka osoittaa tiettyyn tietorakenteen alkioon.

Usein tarvittavat iteraattorit ovat \texttt{begin}
ja \texttt{end}, jotka rajaavat välin,
joka sisältää kaikki tietorakenteen alkiot.
Iteraattori \texttt{begin} osoittaa
tietorakenteen ensimmäiseen alkioon,
kun taas iteraattori \texttt{end} osoittaa
tietorakenteen viimeisen alkion jälkeiseen kohtaan.
Tilanne on siis tällainen:

\begin{center}
\begin{tabular}{llllllllll}
\{ & 3, & 4, & 6, & 8, & 12, & 13, & 14, & 17 & \} \\
& $\uparrow$ & & & & & & & & $\uparrow$ \\
& \multicolumn{3}{l}{\texttt{s.begin()}} & & & & & & \texttt{s.end()} \\
\end{tabular}
\end{center}

Huomaa epäsymmetria iteraattoreissa:
\texttt{s.begin()} osoittaa tietorakenteen alkioon,
kun taas \texttt{s.end()} osoittaa tietorakenteen ulkopuolelle.
Iteraattoreiden rajaama joukon väli on siis \emph{puoliavoin}.

\subsubsection{Välien käsittely}

Iteraattoreita tarvitsee
C++:n standardikirjaston funktioissa, jotka käsittelevät
tietorakenteen välejä.
Yleensä halutaan käsitellä tietorakenteiden kaikkia
alkioita, jolloin funktiolle annetaan
iteraattorit \texttt{begin} ja \texttt{end}.

Esimerkiksi seuraava koodi järjestää vektorin funktiolla \texttt{sort},
kääntää sitten alkioiden järjestyksen funktiolla \texttt{reverse}
ja sekoittaa lopuksi alkioiden järjestyksen funktiolla \texttt{random\_shuffle}.

\index{sort@\texttt{sort}}
\index{reverse@\texttt{reverse}}
\index{random\_shuffle@\texttt{random\_shuffle}}

\begin{lstlisting}
sort(v.begin(), v.end());
reverse(v.begin(), v.end());
random_shuffle(v.begin(), v.end());
\end{lstlisting}

Samoja funktioita voi myös käyttää tavallisen taulukon
yhteydessä, jolloin iteraattorin sijasta annetaan
osoitin taulukkoon:

\begin{lstlisting}
sort(t, t+n);
reverse(t, t+n);
random_shuffle(t, t+n);
\end{lstlisting}

\subsubsection{Joukon iteraattorit}

Iteraattoreita tarvitsee usein joukon
alkioiden käsittelyssä.
Seuraava koodi määrittelee iteraattorin
\texttt{it}, joka osoittaa joukon \texttt{s} alkuun:
\begin{lstlisting}
set<int>::iterator it = s.begin();
\end{lstlisting}
Koodin voi kirjoittaa myös lyhyemmin näin:
\begin{lstlisting}
auto it = s.begin();
\end{lstlisting}
Iteraattoria vastaavaan joukon alkioon
pääsee käsiksi \texttt{*}-merkinnällä.
Esimerkiksi seuraava koodi tulostaa
joukon ensimmäisen alkion:

\begin{lstlisting}
auto it = s.begin();
cout << *it << "\n";
\end{lstlisting}

Iteraattoria pystyy liikuttamaan
operaatioilla \texttt{++} (eteenpäin)
ja \texttt{---} (taaksepäin).
Tällöin iteraattori siirtyy seuraavaan
tai edelliseen alkioon joukossa.

Seuraava koodi tulostaa joukon kaikki alkiot:

\begin{lstlisting}
for (auto it = s.begin(); it != s.end(); it++) {
    cout << *it << "\n";
}
\end{lstlisting}
Seuraava koodi taas tulostaa joukon
viimeisen alkion:

\begin{lstlisting}
auto it = s.end();
it--;
cout << *it << "\n";
\end{lstlisting}
% Iteraattoria täytyi liikuttaa askel taaksepäin,
% koska se osoitti aluksi joukon viimeisen
% alkion jälkeiseen kohtaan.

Funktio $\texttt{find}(x)$ palauttaa iteraattorin
joukon alkioon, jonka arvo on $x$.
Poikkeuksena jos alkiota $x$ ei esiinny joukossa,
iteraattoriksi tulee \texttt{end}.

\begin{lstlisting}
auto it = s.find(x);
if (it == s.end()) cout << "x puuttuu joukosta";
\end{lstlisting}

Funktio $\texttt{lower\_bound}(x)$ palauttaa
iteraattorin joukon pienimpään alkioon,
joka on ainakin yhtä suuri kuin $x$.
Vastaavasti $\texttt{upper\_bound}(x)$ palauttaa
iteraattorin pienimpään alkioon,
joka on suurempi kuin $x$.
Jos tällaisia alkioita ei ole joukossa,
funktiot palauttavat arvon \texttt{end}.
Näitä funktioita ei voi käyttää
\texttt{unordered\_set}-rakenteessa,
joka ei pidä yllä alkioiden järjestystä.

\begin{samepage}
Esimerkiksi seuraava koodi etsii joukosta
alkion, joka on lähinnä lukua $x$:

\begin{lstlisting}
auto a = s.lower_bound(x);
if (a == s.begin() && a == s.end()) {
    cout << "joukko on tyhjä\n";
} else if (a == s.begin()) {
    cout << *a << "\n";
} else if (a == s.end()) {
    a--;
    cout << *a << "\n";
} else {
    auto b = a; b--;
    if (x-*b < *a-x) cout << *b << "\n";
    else cout << *a << "\n";
}
\end{lstlisting}

Koodi käy läpi mahdolliset tapaukset
iteraattorin \texttt{a} avulla.
Iteraattori
osoittaa aluksi pienimpään alkioon,
joka on ainakin yhtä suuri kuin $x$.
Jos \texttt{a} on samaan aikaan \texttt{begin}
ja \texttt{end}, joukko on tyhjä.
Muuten jos \texttt{a} on \texttt{begin},
sen osoittama alkio on $x$:ää lähin alkio.
Jos taas \texttt{a} on \texttt{end},
$x$:ää lähin alkio on joukon viimeinen alkio.
Jos mikään edellisistä tapauksista ei päde,
niin $x$:ää lähin alkio
on joko $a$:n osoittama alkio tai sitä edellinen alkio.
\end{samepage}

\section{Muita tietorakenteita}

\subsubsection{Bittijoukko}

\index{bittijoukko@bittijoukko}
\index{bitset@\texttt{bitset}}

\key{Bittijoukko} (\texttt{bitset}) on taulukko,
jonka jokaisen alkion arvo on 0 tai 1.
Esimerkiksi
seuraava koodi luo bittijoukon, jossa on 10 alkiota.
\begin{lstlisting}
bitset<10> s;
s[2] = 1;
s[5] = 1;
s[6] = 1;
s[8] = 1;
cout << s[4] << "\n"; // 0
cout << s[5] << "\n"; // 1
\end{lstlisting}

Bittijoukon etuna on, että se vie tavallista
taulukkoa vähemmän muistia,
koska jokainen alkio vie
vain yhden bitin muistia.
Esimerkiksi $n$ bitin tallentaminen
\texttt{int}-taulukkona vie $32n$
bittiä tilaa, mutta bittijoukkona
vain $n$ bittiä tilaa.
Lisäksi bittijoukon sisältöä
voi käsitellä tehokkaasti bittioperaatioilla,
minkä ansiosta sillä voi tehostaa algoritmeja.

Seuraava koodi näyttää toisen tavan
bittijoukon luomiseen:

\begin{lstlisting}
bitset<10> s(string("0010011010"));
cout << s[4] << "\n"; // 0
cout << s[5] << "\n"; // 1
\end{lstlisting}

Funktio \texttt{count} palauttaa
bittijoukon ykkösbittien määrän:

\begin{lstlisting}
bitset<10> s(string("0010011010"));
cout << s.count() << "\n"; // 4
\end{lstlisting}

Seuraava koodi näyttää esimerkkejä
bittioperaatioiden käyttämisestä:
\begin{lstlisting}
bitset<10> a(string("0010110110"));
bitset<10> b(string("1011011000"));
cout << (a&b) << "\n"; // 0010010000
cout << (a|b) << "\n"; // 1011111110
cout << (a^b) << "\n"; // 1001101110
\end{lstlisting}

\subsubsection{Pakka}

\index{pakka@pakka}
\index{deque@\texttt{deque}}

\key{Pakka} (\texttt{deque}) on dynaaminen taulukko,
jonka kokoa pystyy muuttamaan tehokkaasti
sekä alku- että loppupäässä.
Pakka sisältää vektorin tavoin
funktiot \texttt{push\_back}
ja \texttt{pop\_back}, mutta siinä on lisäksi myös funktiot
\texttt{push\_front} ja \texttt{pop\_front},
jotka käsittelevät taulukon alkua.

Seuraava koodi esittelee pakan käyttämistä:

\begin{lstlisting}
deque<int> d;
d.push_back(5); // [5]
d.push_back(2); // [5,2]
d.push_front(3); // [3,5,2]
d.pop_back(); // [3,5]
d.pop_front(); // [5]
\end{lstlisting}

Pakan sisäinen toteutus on monimutkaisempi kuin
vektorissa, minkä vuoksi se on
vektoria raskaampi rakenne.
Kuitenkin lisäyksen ja poiston
aikavaativuus on keskimäärin $O(1)$ molemmissa päissä.

\subsubsection{Pino}

\index{pino@pino}
\index{stack@\texttt{stack}}

\key{Pino} (\texttt{stack}) on tietorakenne,
joka tarjoaa kaksi $O(1)$-aikaista
operaatiota:
alkion lisäys pinon päälle ja alkion
poisto pinon päältä.
Pinossa ei ole mahdollista käsitellä muita
alkioita kuin pinon päällimmäistä alkiota.

Seuraava koodi esittelee pinon käyttämistä:

\begin{lstlisting}
stack<int> s;
s.push(3);
s.push(2);
s.push(5);
cout << s.top(); // 5
s.pop();
cout << s.top(); // 2
\end{lstlisting}
\subsubsection{Jono}

\index{jono@jono}
\index{queue@\texttt{queue}}

\key{Jono} (\texttt{queue}) on kuin pino,
mutta alkion lisäys tapahtuu jonon loppuun
ja alkion poisto tapahtuu jonon alusta.
Jonossa on mahdollista käsitellä vain
alussa ja lopussa olevaa alkiota.

Seuraava koodi esittelee jonon käyttämistä:

\begin{lstlisting}
queue<int> s;
s.push(3);
s.push(2);
s.push(5);
cout << s.front(); // 3
s.pop();
cout << s.front(); // 2
\end{lstlisting}
% 
% Huomaa, että rakenteiden \texttt{stack} ja \texttt{queue}
% sijasta voi aina käyttää rakenteita
% \texttt{vector} ja \texttt{deque}, joilla voi
% tehdä kaiken saman ja enemmän.
% Kuitenkin \texttt{stack} ja \texttt{queue} ovat
% kevyempiä ja hieman tehokkaampia rakenteita,
% jos niiden operaatiot riittävät algoritmin toteuttamiseen.

\subsubsection{Prioriteettijono}

\index{prioriteettijono@prioriteettijono}
\index{keko@keko}
\index{priority\_queue@\texttt{priority\_queue}}

\key{Prioriteettijono} (\texttt{priority\_queue})
pitää yllä joukkoa alkioista.
Sen operaatiot ovat alkion lisäys ja
jonon tyypistä riippuen joko
pienimmän alkion haku ja poisto tai
suurimman alkion haku ja poisto.
Lisäyksen ja poiston aikavaativuus on $O(\log n)$
ja haun aikavaativuus on $O(1)$.

Vaikka prioriteettijonon operaatiot
pystyy toteuttamaan myös \texttt{set}-ra\-ken\-teel\-la,
prioriteettijonon etuna on,
että sen kekoon perustuva sisäinen
toteutus on yksinkertaisempi
kuin \texttt{set}-rakenteen tasapainoinen binääripuu,
minkä vuoksi rakenne on kevyempi ja
operaatiot ovat tehokkaampia.

\begin{samepage}
C++:n prioriteettijono toimii oletuksena niin,
että alkiot ovat järjestyksessä suurimmasta pienimpään
ja jonosta pystyy hakemaan ja poistamaan suurimman alkion.
Seuraava koodi esittelee prioriteettijonon käyttämistä:

\begin{lstlisting}
priority_queue<int> q;
q.push(3);
q.push(5);
q.push(7);
q.push(2);
cout << q.top() << "\n"; // 7
q.pop();
cout << q.top() << "\n"; // 5
q.pop();
q.push(6);
cout << q.top() << "\n"; // 6
q.pop();
\end{lstlisting}
\end{samepage}

Seuraava määrittely luo käänteisen prioriteettijonon,
jossa jonosta pystyy hakemaan ja poistamaan pienimmän alkion:

\begin{lstlisting}
priority_queue<int,vector<int>,greater<int>> q;
\end{lstlisting}

\section{Vertailu järjestämiseen}

Monen tehtävän voi ratkaista tehokkaasti joko
käyttäen sopivia tietorakenteita
tai taulukon järjestämistä.
Vaikka erilaiset ratkaisutavat olisivat kaikki
periaatteessa tehokkaita, niissä voi olla
käytännössä merkittäviä eroja.

Tarkastellaan ongelmaa, jossa
annettuna on kaksi listaa $A$ ja $B$,
joista kummassakin on $n$ kokonaislukua.
Tehtävänä on selvittää, moniko luku
esiintyy kummassakin listassa.
Esimerkiksi jos listat ovat
\[A = [5,2,8,9,4] \hspace{10px} \textrm{ja} \hspace{10px} B = [3,2,9,5],\]
niin vastaus on 3, koska luvut 2, 5
ja 9 esiintyvät kummassakin listassa.
Suoraviivainen ratkaisu tehtävään on käydä läpi
kaikki lukuparit ajassa $O(n^2)$, mutta seuraavaksi
keskitymme tehokkaampiin ratkaisuihin.

\subsubsection{Ratkaisu 1}

Tallennetaan listan $A$ luvut joukkoon
ja käydään sitten läpi listan $B$ luvut ja
tarkistetaan jokaisesta, esiintyykö se myös listassa $A$.
Joukon ansiosta on tehokasta tarkastaa,
esiintyykö listan $B$ luku listassa $A$.
Kun joukko toteutetaan \texttt{set}-rakenteella,
algoritmin aikavaativuus on $O(n \log n)$.

\subsubsection{Ratkaisu 2}

Joukon ei tarvitse säilyttää lukuja
järjestyksessä, joten
\texttt{set}-ra\-ken\-teen sijasta voi
käyttää myös \texttt{unordered\_set}-ra\-ken\-net\-ta.
Tämä on helppo tapa parantaa algoritmin
tehokkuutta, koska
algoritmin toteutus säilyy samana ja vain tietorakenne vaihtuu.
Uuden algoritmin aikavaativuus on $O(n)$.

\subsubsection{Ratkaisu 3}

Tietorakenteiden sijasta voimme käyttää järjestämistä.
Järjestetään ensin listat $A$ ja $B$,
minkä jälkeen yhteiset luvut voi löytää
käymällä listat rinnakkain läpi.
Järjestämisen aikavaativuus on $O(n \log n)$ ja
läpikäynnin aikavaativuus on $O(n)$,
joten kokonaisaikavaativuus on $O(n \log n)$.

\subsubsection{Tehokkuusvertailu}

Seuraavassa taulukossa on mittaustuloksia
äskeisten algoritmien tehokkuudesta,
kun $n$ vaihtelee ja listojen luvut ovat
satunnaisia lukuja välillä $1 \ldots 10^9$:

\begin{center}
\begin{tabular}{rrrr}
$n$ & ratkaisu 1 & ratkaisu 2 & ratkaisu 3 \\
\hline
$10^6$ & $1{,}5$ s & $0{,}3$ s & $0{,}2$ s \\
$2 \cdot 10^6$ & $3{,}7$ s & $0{,}8$ s & $0{,}3$ s \\
$3 \cdot 10^6$ & $5{,}7$ s & $1{,}3$ s & $0{,}5$ s \\
$4 \cdot 10^6$ & $7{,}7$ s & $1{,}7$ s & $0{,}7$ s \\
$5 \cdot 10^6$ & $10{,}0$ s & $2{,}3$ s & $0{,}9$ s \\
\end{tabular}
\end{center}

Ratkaisut 1 ja 2 ovat muuten samanlaisia,
mutta ratkaisu 1 käyttää \texttt{set}-rakennetta,
kun taas ratkaisu 2 käyttää
\texttt{unordered\_set}-rakennetta.
Tässä tapauksessa tällä valinnalla on
merkittävä vaikutus suoritusaikaan,
koska ratkaisu 2 on 4–5 kertaa
nopeampi kuin ratkaisu 1.

Tehokkain ratkaisu on kuitenkin järjestämistä
käyttävä ratkaisu 3, joka on vielä puolet
nopeampi kuin ratkaisu 2.
Kiinnostavaa on, että sekä ratkaisun 1 että
ratkaisun 3 aikavaativuus on $O(n \log n)$,
mutta siitä huolimatta
ratkaisu 3 vie aikaa vain kymmenesosan.
Tämän voi selittää sillä, että
järjestäminen on kevyt
operaatio ja se täytyy tehdä vain kerran
ratkaisussa 3 algoritmin alussa,
minkä jälkeen algoritmin loppuosa on lineaarinen.
Ratkaisu 1 taas pitää yllä monimutkaista
tasapainoista binääripuuta koko algoritmin ajan.